## 浅谈单线程的Redis为什么会这么快？

### 一、Redis的历史和概述

#### Redis的历史

08年，意大利的一家创业公司推出了一款基于MySQL的网站实时统计系统，然而没过多久该公司的创始人Salvatore Sanfilippo便开始对MySQL的性能感到失望，于是他决定亲自为该系统量身定做一个数据库，并于**2009年开发完成**，这个数据库就是Redis。在同年Salvatore Sanfilippo将Redis开源发布，并开始和Redis 的另一名主要的代码贡献者Pieter Noordhuis一起继续着Redis的开发。

**Base代码3.5～5w行**。直到今天，Redis的社区还是非常活跃的。Redis到目前已经发布了有**200多个版本**，**最新版本到达6.0+**，**贡献者400多位**，github**⭐45k+**。

#### Redis概述

Redis是一个开源的使用C语言编写，可基于内存 key-value 数据库。Redis 支持不同类型的抽象数据结构，如字符串、列表、映射、集合、有序集合等等。



回到这次分享的主题，单线程的Redis为什么快，主要从以下3个方面去讲

- Redis的基本架构
- Redis的底层数据结构
- Redis的高性能IO模型



#### Redis的基本架构

首先讲Redis的基本架构，先来讲下一个基本的Key-Value数据库需要考虑什么，以及需要什么组件。

- 可以存储哪些数据结构？
  - 不同键值数据库支持的 key 类型一般差异不大，而 value 类型则有较大差别。在对键值数据库进行选型时，一个重要的考虑因素是它支持的 value 类型。
  - Memcached 支持的 value 类型仅为 String 类型。Redis 支持的 value 类型包括了 String、哈希表、列表、集合等。**Redis 能够在实际业务场景中得到广泛的应用，就是得益于支持多样化类型的 value。**
- 可以对数据进行什么操作？
  - 基本操作SET、GET、DEL、SCAN。
  - 对于其他的数据类型也有不同的操作。
- 键值对如何保存？
  - 这个主要看场景，比如缓存场景下，数据需要快速访问，但允许丢失。所以用于该场景下的一般采用内存保存键值数据。
  - Memcached 和 Redis 都是属于内存键值数据库。对于 Redis 而言，缓存是非常重要的一个应用场景。

- 访问框架，访问模式通常有两种：
  - 一种是通过函数库调用的方式供外部应用使用，比如，上图中的 libsimplekv.so，是以动态链接库的形式链接到自己的程序中，提供键值存储功能；RocksDB 以动态链接库的形式使用（RocksDB 是用于键值数据的高性能嵌入式数据库）
  - 另一种是通过网络框架以 Socket 通信的形式对外提供键值对操作，这种形式可以提供广泛的键值存储服务。Memcached 和 Redis 则是通过网络框架访问
    - 通过网络框架提供键值存储服务，一方面扩大了键值数据库的受用面，键值数据库网络框架接收到网络包，并按照相应的协议进行解析之后，就可以知道客户端想要做什么内容。
    - 但另一方面，也给键值数据库的性能、运行模型提供了不同的设计选择，带来了一些潜在的问题。比如：网络连接的处理、网络请求的解析，以及数据存取的处理，是用一个线程、多个线程，还是多个进程来交互处理呢？该如何进行设计和取舍呢？
- 索引模块
  - 索引的作用是让键值数据库根据 key 找到相应 value 的存储位置，进而执行操作。索引的类型有很多，常见的有哈希表、B+ 树、字典树等。不同键值数据库采用的索引并不相同。
    - Memcached 和 Redis 采用哈希表作为 key-value 索引
    - RocksDB 则采用跳表作为内存中 key-value 的索引

- 存储模块
  - 分配器
    - 也就是内存分配器，常用的内存分配器 glibc 的 malloc 和 free。键值数据库的键值对通常大小不一，glibc 的分配器在处理随机的大小内存块分配时，表现并不好。一旦保存的键值对数据规模过大，就可能会造成较严重的内存碎片问题。因此分配器是键值数据库中的一个关键因素。Redis 的内存分配器提供了多种选择，分配效率也不一样。
  - 持久化
    - 持久化可以使得系统在重启后还可以重新提供服务。一般有两种方式进行持久化保存。
      - 一种方式是，对于每一个键值对，都对其进行落盘保存，这虽然让数据更加可靠，但是，因为每次都要写盘，性能会受到很大影响。
      - 另一种方式是，周期性地把内存中的键值数据保存到文件中，这样可以避免频繁写盘操作的性能影响。但是，一个潜在的代价是数据仍然有丢失的风险。

#### Redis的基本架构

- 访问框架：Redis 主要通过网络框架进行访问，而不再是动态库了，这也使得 Redis 可以作为一个基础性的网络服务进行访问，扩大了 Redis 的应用范围。
- 操作模块：Redis 数据模型中的 value 类型很丰富，因此也带来了更多的操作接口，例如面向列表的 LPUSH/LPOP，面向集合的 SADD/SREM 等。后面再value 模型背后的数据结构和操作效率，以及它们对 Redis 性能的影响。
- 索引模块：采用的是hash表对redis进行对key和value进行索引。
- 存储模块：Redis 的持久化模块能支持两种方式：日志（AOF）和快照（RDB），这两种持久化方式具有不同的优劣势，影响到 Redis 的访问性能和可靠性。
- 集群模块：Redis 支持高可靠集群和高可扩展集群，因此，Redis 中包含了相应的集群功能支撑模块。





#### Redis的数据结构

我们常说的Redis的数据结构有五种：String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）。这些只是 Redis 键值对中值的数据类型，也就是数据的保存形式。

Redis的底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。

他们的对应关系如下所示。String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，会把这四种类型称为集合类型，它们的特点是一个键对应了一个集合的数据。



##### redis键值的数据结构

Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以一个哈希表是由多个哈希桶组成的，桶中的元素是entry，那每个entry保存了一个键值对数据，它保存的并不是值本身，而是指向具体值的指针。哈希桶中的 entry 元素中保存了* key和* value指针，分别指向了实际的键和值。

哈希表的最大好处很明显，就是可以用 O(1) 的时间复杂度来快速查找到键值对，只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。虽然哈希表的 O(1) 复杂度可以快速查找到数据，但是也有一个潜在的风险：哈希表的冲突问题和 rehash 可能带来的操作阻塞。

- Redis通过哈希冲突链的方式去解决hash冲突的，同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。这个时候，Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。

















IO网络模型



- 如果一个线程既要处理网络连接、解析请求，又要完成数据存取，一旦某一步操作发生阻塞，整个线程就会阻塞住，这就降低了系统响应速度。
- 如果采用不同线程处理不同操作，那么，某个线程被阻塞时，其他线程还能正常运行。但是，不同线程间如果需要访问共享资源，那又会产生线程竞争，也会影响系统效率。
- Redis是单线程去处理这些内容，如何去解决性能相关的问题呢，在内部都有相应的设计，比如hash表的渐进式rehash过程，高性能的IO模型等等，后面会去讲解。

































